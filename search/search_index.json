{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FLLOAT A Python implementation of the FLLOAT library. Free software: Apache 2.0 license Documentation: https://marcofavorito.github.io/flloat/ Dependencies The package depends on Pythomata . Please follow the install instruction to get all the needed dependencies. Install from PyPI : pip install flloat or, from source ( master branch): pip install git+https://github.com/marcofavorito/flloat.git or, clone the repository and install: git clone htts://github.com/marcofavorito/flloat.git cd flloat pip install . pip install . How to use Parse a LDLf formula: from flloat.parser.ldlf import LDLfParser parser = LDLfParser() formula_string = \"<true*; A & B>tt\" formula = parser(formula_string) # returns a LDLfFormula print(formula) # prints \"<((true)* ; (A & B))>(tt)\" print(formula.find_labels()) # prints {A, B} Evaluate it over finite traces: from flloat.semantics.traces import FiniteTrace t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"}, {} ]) formula.truth(t1, 0) # True Transform it into an automaton ( pythomata.DFA object): dfa = formula.to_automaton() # print the automaton dfa.to_dot(\"./automaton.DFA\") Notice: to_dot requires Graphviz . For info about how to use a pythomata.DFA please look at the Pythomata docs . The same for a LTLf formula: from flloat.parser.ltlf import LTLfParser from flloat.semantics.traces import FiniteTrace # parse the formula parser = LTLfParser() formula_string = \"F (A & !B)\" formula = parser(formula_string) # evaluate over finite traces t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"} ]) assert formula.truth(t1, 0) # from LTLf formula to DFA dfa = formula.to_automaton() assert dfa.accepts(t1.trace) Features Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces Linear Dynamic Logic on Finite Traces; Conversion from LTLf/LDLf formula to DFA Tests To run the tests: tox To run only the code tests: tox -e py37 To run only the code style checks: tox -e flake8 Docs To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000 License Copyright 2018-2019 Marco Favorito","title":"Home"},{"location":"#flloat","text":"A Python implementation of the FLLOAT library. Free software: Apache 2.0 license Documentation: https://marcofavorito.github.io/flloat/","title":"FLLOAT"},{"location":"#dependencies","text":"The package depends on Pythomata . Please follow the install instruction to get all the needed dependencies.","title":"Dependencies"},{"location":"#install","text":"from PyPI : pip install flloat or, from source ( master branch): pip install git+https://github.com/marcofavorito/flloat.git or, clone the repository and install: git clone htts://github.com/marcofavorito/flloat.git cd flloat pip install . pip install .","title":"Install"},{"location":"#how-to-use","text":"Parse a LDLf formula: from flloat.parser.ldlf import LDLfParser parser = LDLfParser() formula_string = \"<true*; A & B>tt\" formula = parser(formula_string) # returns a LDLfFormula print(formula) # prints \"<((true)* ; (A & B))>(tt)\" print(formula.find_labels()) # prints {A, B} Evaluate it over finite traces: from flloat.semantics.traces import FiniteTrace t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"}, {} ]) formula.truth(t1, 0) # True Transform it into an automaton ( pythomata.DFA object): dfa = formula.to_automaton() # print the automaton dfa.to_dot(\"./automaton.DFA\") Notice: to_dot requires Graphviz . For info about how to use a pythomata.DFA please look at the Pythomata docs . The same for a LTLf formula: from flloat.parser.ltlf import LTLfParser from flloat.semantics.traces import FiniteTrace # parse the formula parser = LTLfParser() formula_string = \"F (A & !B)\" formula = parser(formula_string) # evaluate over finite traces t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"} ]) assert formula.truth(t1, 0) # from LTLf formula to DFA dfa = formula.to_automaton() assert dfa.accepts(t1.trace)","title":"How to use"},{"location":"#features","text":"Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces Linear Dynamic Logic on Finite Traces; Conversion from LTLf/LDLf formula to DFA","title":"Features"},{"location":"#tests","text":"To run the tests: tox To run only the code tests: tox -e py37 To run only the code style checks: tox -e flake8","title":"Tests"},{"location":"#docs","text":"To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000","title":"Docs"},{"location":"#license","text":"Copyright 2018-2019 Marco Favorito","title":"License"},{"location":"authors/","text":"Credits Maintainer Marco Favorito < marco.favorito@gmail.com > Contributors None yet. Why not be the first ?","title":"Credits"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#maintainer","text":"Marco Favorito < marco.favorito@gmail.com >","title":"Maintainer"},{"location":"authors/#contributors","text":"None yet. Why not be the first ?","title":"Contributors"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"How to contribute"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"Contributing"},{"location":"references/","text":"References Linear-time Temporal Logic on finite traces (LTLf) and Linear Dynamic Logic on finite traces (LDLf) are two logical formalisms that are at the centre of prolific research activity. In particular, the simplicity and naturalness of LTL for temporal specifications is appealing for fields like: Reasoning about actions and planning Business process specification and verification Here's a list of recommended readings: Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.\" IJCAI (2013) Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces.\" IJCAI (2015) Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability.\" IJCAI (2016) Brafman Ronen, De Giacomo Giuseppe, AND Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\" AAAI (2018)","title":"References"},{"location":"references/#references","text":"Linear-time Temporal Logic on finite traces (LTLf) and Linear Dynamic Logic on finite traces (LDLf) are two logical formalisms that are at the centre of prolific research activity. In particular, the simplicity and naturalness of LTL for temporal specifications is appealing for fields like: Reasoning about actions and planning Business process specification and verification Here's a list of recommended readings: Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.\" IJCAI (2013) Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces.\" IJCAI (2015) Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability.\" IJCAI (2016) Brafman Ronen, De Giacomo Giuseppe, AND Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\" AAAI (2018)","title":"References"}]}