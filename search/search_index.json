{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FLLOAT A Python implementation of the FLLOAT library. Links GitHub: https://github.com/whitemech/flloat PyPI: https://pypi.org/project/flloat/ Documentation: https://whitemech.github.io/flloat Changelog: https://whitemech.github.io/flloat/release-history/ Issue Tracker: https://github.com/whitemech/flloat/issues Download: https://pypi.org/project/flloat/#files Install from PyPI : pip install flloat or, from source ( master branch): pip install git+https://github.com/whitemech/flloat.git or, clone the repository and install: git clone htts://github.com/whitemech/flloat.git cd flloat pip install . How to use Parse a LDLf formula: from flloat.parser.ldlf import LDLfParser parser = LDLfParser() formula_string = \"<true*; a & b>tt\" formula = parser(formula_string) # returns a LDLfFormula print(formula) # prints \"<((true)* ; (a & b))>(tt)\" print(formula.find_labels()) # prints {a, b} Evaluate it over finite traces: t1 = [ {\"a\": False, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": True}, {\"a\": False, \"b\": False}, ] formula.truth(t1, 0) # True Transform it into an automaton ( pythomata.SymbolicAutomaton object): dfa = formula.to_automaton() assert dfa.accepts(t1) # print the automaton graph = dfa.to_graphviz() graph.render(\"./my-automaton\") # requires Graphviz installed on your system. Notice: to_dot requires Graphviz . For info about how to use a pythomata.DFA please look at the Pythomata docs . The same for a LTLf formula: from flloat.parser.ltlf import LTLfParser # parse the formula parser = LTLfParser() formula = \"F (a & !b)\" parsed_formula = parser(formula) # evaluate over finite traces t1 = [ {\"a\": False, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": True}, {\"a\": False, \"b\": False}, ] assert parsed_formula.truth(t1, 0) t2 = [ {\"a\": False, \"b\": False}, {\"a\": True, \"b\": True}, {\"a\": False, \"b\": True}, ] assert not parsed_formula.truth(t2, 0) # from LTLf formula to DFA dfa = parsed_formula.to_automaton() assert dfa.accepts(t1) assert not dfa.accepts(t2) Features Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces Linear Dynamic Logic on Finite Traces; Conversion from LTLf/LDLf formula to DFA Tests To run the tests: tox To run only the code tests: tox -e py37 To run only the code style checks: tox -e flake8 Docs To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000 License FLLOAT is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2018-2020 WhiteMech","title":"Home"},{"location":"#flloat","text":"A Python implementation of the FLLOAT library.","title":"FLLOAT"},{"location":"#links","text":"GitHub: https://github.com/whitemech/flloat PyPI: https://pypi.org/project/flloat/ Documentation: https://whitemech.github.io/flloat Changelog: https://whitemech.github.io/flloat/release-history/ Issue Tracker: https://github.com/whitemech/flloat/issues Download: https://pypi.org/project/flloat/#files","title":"Links"},{"location":"#install","text":"from PyPI : pip install flloat or, from source ( master branch): pip install git+https://github.com/whitemech/flloat.git or, clone the repository and install: git clone htts://github.com/whitemech/flloat.git cd flloat pip install .","title":"Install"},{"location":"#how-to-use","text":"Parse a LDLf formula: from flloat.parser.ldlf import LDLfParser parser = LDLfParser() formula_string = \"<true*; a & b>tt\" formula = parser(formula_string) # returns a LDLfFormula print(formula) # prints \"<((true)* ; (a & b))>(tt)\" print(formula.find_labels()) # prints {a, b} Evaluate it over finite traces: t1 = [ {\"a\": False, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": True}, {\"a\": False, \"b\": False}, ] formula.truth(t1, 0) # True Transform it into an automaton ( pythomata.SymbolicAutomaton object): dfa = formula.to_automaton() assert dfa.accepts(t1) # print the automaton graph = dfa.to_graphviz() graph.render(\"./my-automaton\") # requires Graphviz installed on your system. Notice: to_dot requires Graphviz . For info about how to use a pythomata.DFA please look at the Pythomata docs . The same for a LTLf formula: from flloat.parser.ltlf import LTLfParser # parse the formula parser = LTLfParser() formula = \"F (a & !b)\" parsed_formula = parser(formula) # evaluate over finite traces t1 = [ {\"a\": False, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": False}, {\"a\": True, \"b\": True}, {\"a\": False, \"b\": False}, ] assert parsed_formula.truth(t1, 0) t2 = [ {\"a\": False, \"b\": False}, {\"a\": True, \"b\": True}, {\"a\": False, \"b\": True}, ] assert not parsed_formula.truth(t2, 0) # from LTLf formula to DFA dfa = parsed_formula.to_automaton() assert dfa.accepts(t1) assert not dfa.accepts(t2)","title":"How to use"},{"location":"#features","text":"Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces Linear Dynamic Logic on Finite Traces; Conversion from LTLf/LDLf formula to DFA","title":"Features"},{"location":"#tests","text":"To run the tests: tox To run only the code tests: tox -e py37 To run only the code style checks: tox -e flake8","title":"Tests"},{"location":"#docs","text":"To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000","title":"Docs"},{"location":"#license","text":"FLLOAT is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2018-2020 WhiteMech","title":"License"},{"location":"authors/","text":"Credits Maintainer Marco Favorito < marco.favorito@gmail.com > Contributors Roberto Cipollone < cipollone.rt@gmail.com > Before contributing, please check the page How to contribute .","title":"Credits"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#maintainer","text":"Marco Favorito < marco.favorito@gmail.com >","title":"Maintainer"},{"location":"authors/#contributors","text":"Roberto Cipollone < cipollone.rt@gmail.com > Before contributing, please check the page How to contribute .","title":"Contributors"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"How to contribute"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"Contributing"},{"location":"grammars/","text":"Grammars Here are reported the grammars used by the Lark parser to parse Propositional Logic, LTLf and LDLf. Propositional Logic pl.lark start: propositional_formula ?propositional_formula: prop_equivalence ?prop_equivalence: prop_implication (EQUIVALENCE prop_implication)* ?prop_implication: prop_or (IMPLY prop_or)* ?prop_or: prop_and (OR prop_and)* ?prop_and: prop_not (AND prop_not)* ?prop_not: NOT* prop_wrapped ?prop_wrapped: prop_atom | LSEPARATOR propositional_formula RSEPARATOR ?prop_atom: atom | prop_true | prop_false atom: SYMBOL_NAME prop_true: TRUE prop_false: FALSE LSEPARATOR : \"(\" RSEPARATOR : \")\" EQUIVALENCE : \"<->\" IMPLY : \"->\" OR: \"||\"|\"|\" AND: \"&&\"|\"&\" NOT: \"!\" SYMBOL_NAME: /(\\w+)|(\".*\")/ TRUE.2: /(?i:true)/ FALSE.2: /(?i:false)/ %ignore /\\s+/ LTLf ltlf.lark start: ltlf_formula ?ltlf_formula: ltlf_equivalence ?ltlf_equivalence: ltlf_implication (EQUIVALENCE ltlf_implication)* ?ltlf_implication: ltlf_or (IMPLY ltlf_or)* ?ltlf_or: ltlf_and (OR ltlf_and)* ?ltlf_and: ltlf_until (AND ltlf_until)* ?ltlf_until: ltlf_release (UNTIL ltlf_release)* ?ltlf_release: ltlf_unaryop (RELEASE ltlf_unaryop)* ?ltlf_unaryop: ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_wrapped ?ltlf_always: ALWAYS ltlf_unaryop ?ltlf_eventually: EVENTUALLY ltlf_unaryop ?ltlf_next: NEXT ltlf_unaryop ?ltlf_weak_next: WEAK_NEXT ltlf_unaryop ?ltlf_not: NOT ltlf_unaryop ?ltlf_wrapped: ltlf_atom | LSEPARATOR ltlf_formula RSEPARATOR ?ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false | ltlf_last | ltlf_end ltlf_symbol: SYMBOL_NAME ltlf_true: prop_true ltlf_false: prop_false ltlf_last: LAST ltlf_end: END // Operators must not be part of a word UNTIL.2: /U(?=[^a-z]|$)/ RELEASE.2: /R(?=[^a-z]|$)/ ALWAYS.2: /G(?=[^a-z]|$)/ EVENTUALLY.2: /F(?=[^a-z]|$)/ NEXT.2: /X(?=[^a-z]|$)/ WEAK_NEXT.2: /WX(?=[^a-z]|$)/ END.2: /(?i:end)/ LAST.2: /(?i:last)/ // Symbols cannot contain uppercase letters, because these are reserved SYMBOL_NAME: /[a-z][a-z0-9_]*/ %ignore /\\s+/ %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR LDLf ldlf.lark start: ldlf_formula ?ldlf_formula: ldlf_equivalence ?ldlf_equivalence: ldlf_implication (EQUIVALENCE ldlf_implication)* ?ldlf_implication: ldlf_or (IMPLY ldlf_or)* ?ldlf_or: ldlf_and (OR ldlf_and)* ?ldlf_and: ldlf_unaryop (AND ldlf_unaryop)* ?ldlf_unaryop: ldlf_box | ldlf_diamond | ldlf_not | ldlf_wrapped ?ldlf_box: BOXLSEPARATOR regular_expression BOXRSEPARATOR ldlf_unaryop ?ldlf_diamond: DIAMONDLSEPARATOR regular_expression DIAMONDRSEPARATOR ldlf_unaryop ?ldlf_not: NOT ldlf_unaryop ?ldlf_wrapped: ldlf_atom | LSEPARATOR ldlf_formula RSEPARATOR ?ldlf_atom: ldlf_tt | ldlf_ff | ldlf_last | ldlf_end | ldlf_prop_true | ldlf_prop_false | ldlf_prop_atom ldlf_prop_true: TRUE ldlf_prop_false: FALSE ldlf_prop_atom: SYMBOL_NAME ldlf_tt: TT ldlf_ff: FF ldlf_last: LAST ldlf_end: END regular_expression: re_union ?re_union: re_sequence (UNION re_sequence)* ?re_sequence: re_star (SEQ re_star)* ?re_star: re_test STAR? ?re_test: TEST ldlf_formula | re_wrapped ?re_wrapped: re_propositional | LSEPARATOR regular_expression RSEPARATOR re_propositional: propositional_formula BOXLSEPARATOR: \"[\" BOXRSEPARATOR: \"]\" DIAMONDLSEPARATOR: \"<\" DIAMONDRSEPARATOR: \">\" UNION: \"+\" SEQ: \";\" TEST: \"?\" STAR: \"*\" TT.2: /(?i:tt)/ FF.2: /(?i:ff)/ %ignore /\\s+/ %import .pl.propositional_formula %import .pl.TRUE -> TRUE %import .pl.FALSE -> FALSE %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.NOT -> NOT %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR %import .ltlf.LAST -> LAST %import .ltlf.END -> END","title":"Grammars"},{"location":"grammars/#grammars","text":"Here are reported the grammars used by the Lark parser to parse Propositional Logic, LTLf and LDLf.","title":"Grammars"},{"location":"grammars/#propositional-logic","text":"pl.lark start: propositional_formula ?propositional_formula: prop_equivalence ?prop_equivalence: prop_implication (EQUIVALENCE prop_implication)* ?prop_implication: prop_or (IMPLY prop_or)* ?prop_or: prop_and (OR prop_and)* ?prop_and: prop_not (AND prop_not)* ?prop_not: NOT* prop_wrapped ?prop_wrapped: prop_atom | LSEPARATOR propositional_formula RSEPARATOR ?prop_atom: atom | prop_true | prop_false atom: SYMBOL_NAME prop_true: TRUE prop_false: FALSE LSEPARATOR : \"(\" RSEPARATOR : \")\" EQUIVALENCE : \"<->\" IMPLY : \"->\" OR: \"||\"|\"|\" AND: \"&&\"|\"&\" NOT: \"!\" SYMBOL_NAME: /(\\w+)|(\".*\")/ TRUE.2: /(?i:true)/ FALSE.2: /(?i:false)/ %ignore /\\s+/","title":"Propositional Logic"},{"location":"grammars/#ltlf","text":"ltlf.lark start: ltlf_formula ?ltlf_formula: ltlf_equivalence ?ltlf_equivalence: ltlf_implication (EQUIVALENCE ltlf_implication)* ?ltlf_implication: ltlf_or (IMPLY ltlf_or)* ?ltlf_or: ltlf_and (OR ltlf_and)* ?ltlf_and: ltlf_until (AND ltlf_until)* ?ltlf_until: ltlf_release (UNTIL ltlf_release)* ?ltlf_release: ltlf_unaryop (RELEASE ltlf_unaryop)* ?ltlf_unaryop: ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_wrapped ?ltlf_always: ALWAYS ltlf_unaryop ?ltlf_eventually: EVENTUALLY ltlf_unaryop ?ltlf_next: NEXT ltlf_unaryop ?ltlf_weak_next: WEAK_NEXT ltlf_unaryop ?ltlf_not: NOT ltlf_unaryop ?ltlf_wrapped: ltlf_atom | LSEPARATOR ltlf_formula RSEPARATOR ?ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false | ltlf_last | ltlf_end ltlf_symbol: SYMBOL_NAME ltlf_true: prop_true ltlf_false: prop_false ltlf_last: LAST ltlf_end: END // Operators must not be part of a word UNTIL.2: /U(?=[^a-z]|$)/ RELEASE.2: /R(?=[^a-z]|$)/ ALWAYS.2: /G(?=[^a-z]|$)/ EVENTUALLY.2: /F(?=[^a-z]|$)/ NEXT.2: /X(?=[^a-z]|$)/ WEAK_NEXT.2: /WX(?=[^a-z]|$)/ END.2: /(?i:end)/ LAST.2: /(?i:last)/ // Symbols cannot contain uppercase letters, because these are reserved SYMBOL_NAME: /[a-z][a-z0-9_]*/ %ignore /\\s+/ %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"LTLf"},{"location":"grammars/#ldlf","text":"ldlf.lark start: ldlf_formula ?ldlf_formula: ldlf_equivalence ?ldlf_equivalence: ldlf_implication (EQUIVALENCE ldlf_implication)* ?ldlf_implication: ldlf_or (IMPLY ldlf_or)* ?ldlf_or: ldlf_and (OR ldlf_and)* ?ldlf_and: ldlf_unaryop (AND ldlf_unaryop)* ?ldlf_unaryop: ldlf_box | ldlf_diamond | ldlf_not | ldlf_wrapped ?ldlf_box: BOXLSEPARATOR regular_expression BOXRSEPARATOR ldlf_unaryop ?ldlf_diamond: DIAMONDLSEPARATOR regular_expression DIAMONDRSEPARATOR ldlf_unaryop ?ldlf_not: NOT ldlf_unaryop ?ldlf_wrapped: ldlf_atom | LSEPARATOR ldlf_formula RSEPARATOR ?ldlf_atom: ldlf_tt | ldlf_ff | ldlf_last | ldlf_end | ldlf_prop_true | ldlf_prop_false | ldlf_prop_atom ldlf_prop_true: TRUE ldlf_prop_false: FALSE ldlf_prop_atom: SYMBOL_NAME ldlf_tt: TT ldlf_ff: FF ldlf_last: LAST ldlf_end: END regular_expression: re_union ?re_union: re_sequence (UNION re_sequence)* ?re_sequence: re_star (SEQ re_star)* ?re_star: re_test STAR? ?re_test: TEST ldlf_formula | re_wrapped ?re_wrapped: re_propositional | LSEPARATOR regular_expression RSEPARATOR re_propositional: propositional_formula BOXLSEPARATOR: \"[\" BOXRSEPARATOR: \"]\" DIAMONDLSEPARATOR: \"<\" DIAMONDRSEPARATOR: \">\" UNION: \"+\" SEQ: \";\" TEST: \"?\" STAR: \"*\" TT.2: /(?i:tt)/ FF.2: /(?i:ff)/ %ignore /\\s+/ %import .pl.propositional_formula %import .pl.TRUE -> TRUE %import .pl.FALSE -> FALSE %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.NOT -> NOT %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR %import .ltlf.LAST -> LAST %import .ltlf.END -> END","title":"LDLf"},{"location":"references/","text":"References Linear-time Temporal Logic on finite traces (LTLf) and Linear Dynamic Logic on finite traces (LDLf) are two logical formalisms that are at the centre of prolific research activity. In particular, the simplicity and naturalness of LTL for temporal specifications is appealing for fields like: Reasoning about actions and planning Business process specification and verification Here's a list of recommended readings: Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.\" IJCAI (2013) Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces.\" IJCAI (2015) Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability.\" IJCAI (2016) Brafman Ronen, De Giacomo Giuseppe, AND Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\" AAAI (2018)","title":"References"},{"location":"references/#references","text":"Linear-time Temporal Logic on finite traces (LTLf) and Linear Dynamic Logic on finite traces (LDLf) are two logical formalisms that are at the centre of prolific research activity. In particular, the simplicity and naturalness of LTL for temporal specifications is appealing for fields like: Reasoning about actions and planning Business process specification and verification Here's a list of recommended readings: Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.\" IJCAI (2013) Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces.\" IJCAI (2015) Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability.\" IJCAI (2016) Brafman Ronen, De Giacomo Giuseppe, AND Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\" AAAI (2018)","title":"References"},{"location":"release-history/","text":"History 0.3.0 (2020-03-24) Refinement of all the grammars. Extensive improvement of the parsing. Integration with Pythomata >=0.3.0 Simplified interfaces and refactoring of the class hierarchy for the logic modules. Introduced FiniteTraceWrapper. It allows evaluating any propositional over a finite trace. Several bug fixes and improved testing. Improvement of docs and metadata consistency. 0.2.3 (2019-10-10) Reverting some changes made on release 0.2.2 . Updated live version: http://flloat.herokuapp.com/ 0.2.2 (2019-10-09) Fix several issues in the computation of the delta function for LDLf. 0.2.1 (2019-10-09) Replace parsing library PLY with Lark . 0.2.0 (2019-10-06) Main refactoring of the package. No new features. 0.1.3 (2018-04-20) Support for LTLf formulas and conversion into NFA, DFA and DFA on-the-fly 0.1.1 (2018-04-15) Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Dynamic Logic on Finite Traces; Conversion from LDLf formula to NFA, DFA and DFA on-the-fly 0.1.0 (2018-04-11) First release on PyPI.","title":"Release History"},{"location":"release-history/#history","text":"","title":"History"},{"location":"release-history/#030-2020-03-24","text":"Refinement of all the grammars. Extensive improvement of the parsing. Integration with Pythomata >=0.3.0 Simplified interfaces and refactoring of the class hierarchy for the logic modules. Introduced FiniteTraceWrapper. It allows evaluating any propositional over a finite trace. Several bug fixes and improved testing. Improvement of docs and metadata consistency.","title":"0.3.0 (2020-03-24)"},{"location":"release-history/#023-2019-10-10","text":"Reverting some changes made on release 0.2.2 . Updated live version: http://flloat.herokuapp.com/","title":"0.2.3 (2019-10-10)"},{"location":"release-history/#022-2019-10-09","text":"Fix several issues in the computation of the delta function for LDLf.","title":"0.2.2 (2019-10-09)"},{"location":"release-history/#021-2019-10-09","text":"Replace parsing library PLY with Lark .","title":"0.2.1 (2019-10-09)"},{"location":"release-history/#020-2019-10-06","text":"Main refactoring of the package. No new features.","title":"0.2.0 (2019-10-06)"},{"location":"release-history/#013-2018-04-20","text":"Support for LTLf formulas and conversion into NFA, DFA and DFA on-the-fly","title":"0.1.3 (2018-04-20)"},{"location":"release-history/#011-2018-04-15","text":"Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Dynamic Logic on Finite Traces; Conversion from LDLf formula to NFA, DFA and DFA on-the-fly","title":"0.1.1 (2018-04-15)"},{"location":"release-history/#010-2018-04-11","text":"First release on PyPI.","title":"0.1.0 (2018-04-11)"}]}