{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FLLOAT A Python implementation of the FLLOAT library. Free software: Apache 2.0 license Documentation: https://marcofavorito.github.io/flloat/ Dependencies The package depends on Pythomata . Please follow the install instruction to get all the needed dependencies. Install from PyPI : pip install flloat or, from source ( master branch): pip install git+https://github.com/marcofavorito/flloat.git or, clone the repository and install: git clone htts://github.com/marcofavorito/flloat.git cd flloat pip install . How to use Parse a LDLf formula: from flloat.parser.ldlf import LDLfParser parser = LDLfParser() formula_string = \"<true*; A & B>tt\" formula = parser(formula_string) # returns a LDLfFormula print(formula) # prints \"<((true)* ; (A & B))>(tt)\" print(formula.find_labels()) # prints {A, B} Evaluate it over finite traces: from flloat.semantics.traces import FiniteTrace t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"}, {} ]) formula.truth(t1, 0) # True Transform it into an automaton ( pythomata.DFA object): dfa = formula.to_automaton() # print the automaton dfa.to_dot(\"./automaton.DFA\") Notice: to_dot requires Graphviz . For info about how to use a pythomata.DFA please look at the Pythomata docs . The same for a LTLf formula: from flloat.parser.ltlf import LTLfParser from flloat.semantics.traces import FiniteTrace # parse the formula parser = LTLfParser() formula_string = \"F (A & !B)\" formula = parser(formula_string) # evaluate over finite traces t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"} ]) assert formula.truth(t1, 0) # from LTLf formula to DFA dfa = formula.to_automaton() assert dfa.accepts(t1.trace) Features Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces Linear Dynamic Logic on Finite Traces; Conversion from LTLf/LDLf formula to DFA Tests To run the tests: tox To run only the code tests: tox -e py37 To run only the code style checks: tox -e flake8 Docs To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000 License Copyright 2018-2019 Marco Favorito","title":"Home"},{"location":"#flloat","text":"A Python implementation of the FLLOAT library. Free software: Apache 2.0 license Documentation: https://marcofavorito.github.io/flloat/","title":"FLLOAT"},{"location":"#dependencies","text":"The package depends on Pythomata . Please follow the install instruction to get all the needed dependencies.","title":"Dependencies"},{"location":"#install","text":"from PyPI : pip install flloat or, from source ( master branch): pip install git+https://github.com/marcofavorito/flloat.git or, clone the repository and install: git clone htts://github.com/marcofavorito/flloat.git cd flloat pip install .","title":"Install"},{"location":"#how-to-use","text":"Parse a LDLf formula: from flloat.parser.ldlf import LDLfParser parser = LDLfParser() formula_string = \"<true*; A & B>tt\" formula = parser(formula_string) # returns a LDLfFormula print(formula) # prints \"<((true)* ; (A & B))>(tt)\" print(formula.find_labels()) # prints {A, B} Evaluate it over finite traces: from flloat.semantics.traces import FiniteTrace t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"}, {} ]) formula.truth(t1, 0) # True Transform it into an automaton ( pythomata.DFA object): dfa = formula.to_automaton() # print the automaton dfa.to_dot(\"./automaton.DFA\") Notice: to_dot requires Graphviz . For info about how to use a pythomata.DFA please look at the Pythomata docs . The same for a LTLf formula: from flloat.parser.ltlf import LTLfParser from flloat.semantics.traces import FiniteTrace # parse the formula parser = LTLfParser() formula_string = \"F (A & !B)\" formula = parser(formula_string) # evaluate over finite traces t1 = FiniteTrace.from_symbol_sets([ {}, {\"A\"}, {\"A\"}, {\"A\", \"B\"} ]) assert formula.truth(t1, 0) # from LTLf formula to DFA dfa = formula.to_automaton() assert dfa.accepts(t1.trace)","title":"How to use"},{"location":"#features","text":"Syntax, semantics and parsing support for the following formal languages: Propositional Logic; Linear Temporal Logic on Finite Traces Linear Dynamic Logic on Finite Traces; Conversion from LTLf/LDLf formula to DFA","title":"Features"},{"location":"#tests","text":"To run the tests: tox To run only the code tests: tox -e py37 To run only the code style checks: tox -e flake8","title":"Tests"},{"location":"#docs","text":"To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000","title":"Docs"},{"location":"#license","text":"Copyright 2018-2019 Marco Favorito","title":"License"},{"location":"authors/","text":"Credits Maintainer Marco Favorito < marco.favorito@gmail.com > Contributors None yet. Why not be the first ?","title":"Credits"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#maintainer","text":"Marco Favorito < marco.favorito@gmail.com >","title":"Maintainer"},{"location":"authors/#contributors","text":"None yet. Why not be the first ?","title":"Contributors"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"How to contribute"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"Contributing"},{"location":"grammars/","text":"Grammars Here are reported the grammars used by the Lark parser to parse Propositional Logic, LTLf and LDLf. Propositional Logic pl.lark start: propositional_formula propositional_formula: wrapped_prop | equivalence_prop | implication_prop | or_prop | and_prop | not_prop | atom_prop wrapped_prop: LSEPARATOR propositional_formula RSEPARATOR equivalence_prop.5: propositional_formula EQUIVALENCE propositional_formula implication_prop.4: propositional_formula IMPLY propositional_formula or_prop.3: propositional_formula OR propositional_formula and_prop.2: propositional_formula AND propositional_formula not_prop.1: NOT propositional_formula atom_prop: atom | true_prop | false_prop atom: string* true_prop.1: TRUE false_prop.1: FALSE string: /\\w/+ TRUE : \"True\" | \"TRUE\" | \"true\" FALSE : \"False\" | \"FALSE\" | \"false\" EQUIVALENCE : \"<->\" IMPLY : \"->\" OR : \"||\"|\"|\" AND : \"&&\"|\"&\" NOT : \"!\" LSEPARATOR : \"(\" RSEPARATOR : \")\" WHITESPACE: (\" \" | \"\\n\")+ %ignore WHITESPACE LTLf ltlf.lark start: ltlf_formula ltlf_formula: ltlf_wrapped | ltlf_equivalence | ltlf_implication | ltlf_or | ltlf_and | ltlf_until | ltlf_release | ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_atom ltlf_wrapped: LSEPARATOR ltlf_formula RSEPARATOR ltlf_equivalence.8: ltlf_formula EQUIVALENCE ltlf_formula ltlf_implication.7: ltlf_formula IMPLY ltlf_formula ltlf_or.6: ltlf_formula OR ltlf_formula ltlf_and.5: ltlf_formula AND ltlf_formula ltlf_until.4: ltlf_formula UNTIL ltlf_formula ltlf_release.4: ltlf_formula RELEASE ltlf_formula ltlf_always.3: ALWAYS ltlf_formula ltlf_eventually.3: EVENTUALLY ltlf_formula ltlf_next.2: NEXT ltlf_formula ltlf_weak_next.2: WEAK_NEXT ltlf_formula ltlf_not.1: NOT ltlf_formula ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false ltlf_true: true_prop ltlf_false: false_prop ltlf_symbol: string UNTIL: \"U\" RELEASE: \"R\" ALWAYS: \"G\" EVENTUALLY: \"F\" NEXT: \"X\" WEAK_NEXT: \"WX\" END: \"END\"|\"end\"|\"End\" LAST: \"LAST\"|\"last\"|\"Last\" WHITESPACE: (\" \" | \"\\n\")+ %ignore WHITESPACE %import .pl.string -> string %import .pl.true_prop -> true_prop %import .pl.false_prop -> false_prop %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR LDLf ldlf.lark start: ldlf_formula ldlf_formula: ldlf_wrapped | ldlf_equivalence | ldlf_implication | ldlf_or | ldlf_and | ldlf_box | ldlf_diamond | ldlf_not | ldlf_atom ldlf_wrapped: LSEPARATOR ldlf_formula RSEPARATOR ldlf_equivalence.6: ldlf_formula EQUIVALENCE ldlf_formula ldlf_implication.5: ldlf_formula IMPLY ldlf_formula ldlf_or.4: ldlf_formula OR ldlf_formula ldlf_and.3: ldlf_formula AND ldlf_formula ldlf_box.2: BOXLSEPARATOR regular_expression BOXRSEPARATOR ldlf_formula ldlf_diamond.2: DIAMONDLSEPARATOR regular_expression DIAMONDRSEPARATOR ldlf_formula ldlf_not.1: NOT ldlf_formula ldlf_atom: ldlf_tt | ldlf_ff | ldlf_last | ldlf_end | ldlf_true | ldlf_false | ldlf_symbol ldlf_tt: TT ldlf_ff: FF ldlf_last: LAST ldlf_end: END ldlf_true: true_prop ldlf_false: false_prop ldlf_symbol: string regular_expression: wrapped_regular_expression | regular_expression_union | regular_expression_sequence | regular_expression_test | regular_expression_star | regular_expression_propositional wrapped_regular_expression: LSEPARATOR regular_expression RSEPARATOR regular_expression_union.3: regular_expression UNION regular_expression regular_expression_sequence.3: regular_expression SEQ regular_expression regular_expression_test.2: ldlf_formula TEST regular_expression_star.2: regular_expression STAR regular_expression_propositional.1: propositional_formula %import common.ESCAPED_STRING WHITESPACE: (\" \" | \"\\n\")+ BOXLSEPARATOR: \"[\" BOXRSEPARATOR: \"]\" DIAMONDLSEPARATOR: \"<\" DIAMONDRSEPARATOR: \">\" TT: \"tt\" FF: \"ff\" LAST: \"last\" END: \"end\" UNION: \"+\" SEQ: \";\" TEST: \"?\" STAR: \"*\" %ignore WHITESPACE %import .pl.start -> propositional_formula %import .pl.string -> string %import .pl.true_prop -> true_prop %import .pl.false_prop -> false_prop %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.NOT -> NOT %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"Grammars"},{"location":"grammars/#grammars","text":"Here are reported the grammars used by the Lark parser to parse Propositional Logic, LTLf and LDLf.","title":"Grammars"},{"location":"grammars/#propositional-logic","text":"pl.lark start: propositional_formula propositional_formula: wrapped_prop | equivalence_prop | implication_prop | or_prop | and_prop | not_prop | atom_prop wrapped_prop: LSEPARATOR propositional_formula RSEPARATOR equivalence_prop.5: propositional_formula EQUIVALENCE propositional_formula implication_prop.4: propositional_formula IMPLY propositional_formula or_prop.3: propositional_formula OR propositional_formula and_prop.2: propositional_formula AND propositional_formula not_prop.1: NOT propositional_formula atom_prop: atom | true_prop | false_prop atom: string* true_prop.1: TRUE false_prop.1: FALSE string: /\\w/+ TRUE : \"True\" | \"TRUE\" | \"true\" FALSE : \"False\" | \"FALSE\" | \"false\" EQUIVALENCE : \"<->\" IMPLY : \"->\" OR : \"||\"|\"|\" AND : \"&&\"|\"&\" NOT : \"!\" LSEPARATOR : \"(\" RSEPARATOR : \")\" WHITESPACE: (\" \" | \"\\n\")+ %ignore WHITESPACE","title":"Propositional Logic"},{"location":"grammars/#ltlf","text":"ltlf.lark start: ltlf_formula ltlf_formula: ltlf_wrapped | ltlf_equivalence | ltlf_implication | ltlf_or | ltlf_and | ltlf_until | ltlf_release | ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_atom ltlf_wrapped: LSEPARATOR ltlf_formula RSEPARATOR ltlf_equivalence.8: ltlf_formula EQUIVALENCE ltlf_formula ltlf_implication.7: ltlf_formula IMPLY ltlf_formula ltlf_or.6: ltlf_formula OR ltlf_formula ltlf_and.5: ltlf_formula AND ltlf_formula ltlf_until.4: ltlf_formula UNTIL ltlf_formula ltlf_release.4: ltlf_formula RELEASE ltlf_formula ltlf_always.3: ALWAYS ltlf_formula ltlf_eventually.3: EVENTUALLY ltlf_formula ltlf_next.2: NEXT ltlf_formula ltlf_weak_next.2: WEAK_NEXT ltlf_formula ltlf_not.1: NOT ltlf_formula ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false ltlf_true: true_prop ltlf_false: false_prop ltlf_symbol: string UNTIL: \"U\" RELEASE: \"R\" ALWAYS: \"G\" EVENTUALLY: \"F\" NEXT: \"X\" WEAK_NEXT: \"WX\" END: \"END\"|\"end\"|\"End\" LAST: \"LAST\"|\"last\"|\"Last\" WHITESPACE: (\" \" | \"\\n\")+ %ignore WHITESPACE %import .pl.string -> string %import .pl.true_prop -> true_prop %import .pl.false_prop -> false_prop %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"LTLf"},{"location":"grammars/#ldlf","text":"ldlf.lark start: ldlf_formula ldlf_formula: ldlf_wrapped | ldlf_equivalence | ldlf_implication | ldlf_or | ldlf_and | ldlf_box | ldlf_diamond | ldlf_not | ldlf_atom ldlf_wrapped: LSEPARATOR ldlf_formula RSEPARATOR ldlf_equivalence.6: ldlf_formula EQUIVALENCE ldlf_formula ldlf_implication.5: ldlf_formula IMPLY ldlf_formula ldlf_or.4: ldlf_formula OR ldlf_formula ldlf_and.3: ldlf_formula AND ldlf_formula ldlf_box.2: BOXLSEPARATOR regular_expression BOXRSEPARATOR ldlf_formula ldlf_diamond.2: DIAMONDLSEPARATOR regular_expression DIAMONDRSEPARATOR ldlf_formula ldlf_not.1: NOT ldlf_formula ldlf_atom: ldlf_tt | ldlf_ff | ldlf_last | ldlf_end | ldlf_true | ldlf_false | ldlf_symbol ldlf_tt: TT ldlf_ff: FF ldlf_last: LAST ldlf_end: END ldlf_true: true_prop ldlf_false: false_prop ldlf_symbol: string regular_expression: wrapped_regular_expression | regular_expression_union | regular_expression_sequence | regular_expression_test | regular_expression_star | regular_expression_propositional wrapped_regular_expression: LSEPARATOR regular_expression RSEPARATOR regular_expression_union.3: regular_expression UNION regular_expression regular_expression_sequence.3: regular_expression SEQ regular_expression regular_expression_test.2: ldlf_formula TEST regular_expression_star.2: regular_expression STAR regular_expression_propositional.1: propositional_formula %import common.ESCAPED_STRING WHITESPACE: (\" \" | \"\\n\")+ BOXLSEPARATOR: \"[\" BOXRSEPARATOR: \"]\" DIAMONDLSEPARATOR: \"<\" DIAMONDRSEPARATOR: \">\" TT: \"tt\" FF: \"ff\" LAST: \"last\" END: \"end\" UNION: \"+\" SEQ: \";\" TEST: \"?\" STAR: \"*\" %ignore WHITESPACE %import .pl.start -> propositional_formula %import .pl.string -> string %import .pl.true_prop -> true_prop %import .pl.false_prop -> false_prop %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.NOT -> NOT %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"LDLf"},{"location":"references/","text":"References Linear-time Temporal Logic on finite traces (LTLf) and Linear Dynamic Logic on finite traces (LDLf) are two logical formalisms that are at the centre of prolific research activity. In particular, the simplicity and naturalness of LTL for temporal specifications is appealing for fields like: Reasoning about actions and planning Business process specification and verification Here's a list of recommended readings: Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.\" IJCAI (2013) Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces.\" IJCAI (2015) Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability.\" IJCAI (2016) Brafman Ronen, De Giacomo Giuseppe, AND Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\" AAAI (2018)","title":"References"},{"location":"references/#references","text":"Linear-time Temporal Logic on finite traces (LTLf) and Linear Dynamic Logic on finite traces (LDLf) are two logical formalisms that are at the centre of prolific research activity. In particular, the simplicity and naturalness of LTL for temporal specifications is appealing for fields like: Reasoning about actions and planning Business process specification and verification Here's a list of recommended readings: Giuseppe De Giacomo and Moshe Y. Vardi. \"Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.\" IJCAI (2013) Giuseppe De Giacomo and Moshe Y. Vardi. \"Synthesis for LTL and LDL on finite traces.\" IJCAI (2015) Giuseppe De Giacomo and Moshe Y. Vardi. \"LTLf and LDLf synthesis under partial observability.\" IJCAI (2016) Brafman Ronen, De Giacomo Giuseppe, AND Patrizi Fabio. \"LTLf/LDLf Non-Markovian Rewards\" AAAI (2018)","title":"References"}]}